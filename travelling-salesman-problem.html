<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP Visualizer</title>
    <style>
        /* --- MAIN STYLING (From CSS Block) --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        h1 { margin-bottom: 5px; color: #fff; }
        
        #status { 
            color: #4caf50; 
            margin-bottom: 20px; 
            font-size: 1.1em; 
            font-weight: bold;
            min-height: 25px;
        }

        canvas {
            background-color: #000;
            border: 1px solid #333;
            cursor: crosshair;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            border-radius: 4px;
        }

        .controls { margin-top: 20px; display: flex; gap: 10px; }

        button {
            padding: 12px 24px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-start { background-color: #2e7d32; color: white; }
        .btn-start:hover { background-color: #1b5e20; transform: translateY(-1px); }
        .btn-start:disabled { background-color: #444; color: #888; cursor: not-allowed; transform: none; }

        .btn-reset { background-color: #c62828; color: white; }
        .btn-reset:hover { background-color: #b71c1c; transform: translateY(-1px); }

        /* --- PROGRESS BAR STYLING (From HTML Block) --- */
        #progress-container {
            width: 600px;
            height: 10px;
            background: #333;
            margin: 0 auto 15px auto;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #444;
        }
        
        #progress-bar {
            width: 0%;
            height: 100%;
            background: #00e676;
            transition: width 0.1s;
            box-shadow: 0 0 10px #00e676;
        }
    </style>
</head>
<body>

    <h1>TSP Visualizer</h1>
    <div id="status">Click on the black box to add cities...</div>

    <div id="progress-container">
        <div id="progress-bar"></div>
    </div>

    <canvas id="canvas" width="600" height="500"></canvas>

    <div class="controls">
        <button onclick="startSolver()" class="btn-start">Start Brute Force</button>
        <button onclick="location.reload()" class="btn-reset">Reset</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const output = document.getElementById('status');
        const progressBar = document.getElementById('progress-bar');

        let cities = [];
        let solver = null;
        let bestDist = Infinity;
        let bestPath = [];
        let isRunning = false;
        let totalPermutations = 0;
        let currentCount = 0;

        // Mouse click handler to add cities
        canvas.addEventListener('mousedown', (e) => {
            if (isRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            cities.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });

            draw([], cities, "white");
            output.innerText = `Added City ${cities.length}`;
        });

        function startSolver() {
            if (cities.length < 3) {
                output.innerText = "Please add at least 3 cities.";
                return;
            }
            
            isRunning = true;
            bestDist = Infinity;
            currentCount = 0;
            
            // Factorial of (N-1) because we fix the starting city
            totalPermutations = factorial(cities.length - 1);

            const cityIndexes = cities.map((_, i) => i).slice(1); 
            solver = permute(cityIndexes); 

            animate();
        }

        function animate() {
            if (!isRunning) return;

            // Batch processing: Process 2000 iterations per frame for speed
            for (let i = 0; i < 2000; i++) {
                const next = solver.next();
                currentCount++;

                if (next.done) {
                    isRunning = false;
                    progressBar.style.width = "100%";
                    draw(bestPath, bestPath, "#00ff00");
                    output.innerText = `Finished! Best Distance: ${Math.floor(bestDist)}`;
                    return;
                }

                // Construct path: Start(0) -> Permutation -> End(0)
                const currentOrder = [0, ...next.value, 0];
                const currentPath = currentOrder.map(index => cities[index]);

                const d = calculateDist(currentPath);
                if (d < bestDist) {
                    bestDist = d;
                    bestPath = currentPath;
                    output.innerText = `New Best: ${Math.floor(d)}`;
                }
            }
            
            // Update UI
            const percentage = Math.min((currentCount / totalPermutations) * 100, 100);
            progressBar.style.width = percentage + "%";

            // Draw current best path
            draw(bestPath, cities, "white"); 
            requestAnimationFrame(animate);
        }

        // Generator for permutations
        function* permute(arr, m = []) {
            if (arr.length === 0) {
                yield m;
            } else {
                for (let i = 0; i < arr.length; i++) {
                    let curr = arr.slice();
                    let next = curr.splice(i, 1);
                    yield* permute(curr, m.concat(next));
                }
            }
        }

        function calculateDist(points) {
            let sum = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i].x - points[i+1].x;
                const dy = points[i].y - points[i+1].y;
                sum += Math.sqrt(dx*dx + dy*dy);
            }
            return sum;
        }

        function draw(path, allCities, color) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Paths
            if (path.length > 0) {
                ctx.strokeStyle = color === "white" ? "#00e676" : color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let p of path) ctx.lineTo(p.x, p.y);
                ctx.stroke();
            }

            // Draw Cities
            for (let i = 0; i < allCities.length; i++) {
                ctx.fillStyle = (i === 0) ? "#ff3333" : "white"; // Start city is Red
                ctx.beginPath();
                ctx.arc(allCities[i].x, allCities[i].y, 6, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function factorial(n) {
            let r = 1;
            for (let i = 2; i <= n; i++) r *= i;
            return r;
        }
    </script>
</body>
</html>